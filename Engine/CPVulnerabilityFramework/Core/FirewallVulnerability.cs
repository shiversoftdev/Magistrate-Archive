using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CPVulnerabilityFramework.Core
{
    /// <summary>
    /// Success: When the specified condition is met, Regression: Yes, Failure: No
    /// </summary>
    public sealed class FirewallVulnerability : Vulnerability
    {
        /// <summary>
        /// The type of firewall vulnerability
        /// </summary>
        public enum FirewallVulnerabilityType
        {
            /// <summary>
            /// Is the firewall enabled
            /// </summary>
            Enabled,
            /// <summary>
            /// Is the firewall disabled
            /// </summary>
            Disabled,
            /// <summary>
            /// Is a certain port allowed
            /// </summary>
            PortAllowed,
            /// <summary>
            /// Is a certain port blocked
            /// </summary>
            PortBlocked,
            /// <summary>
            /// Is an application allowed through firewall
            /// </summary>
            ApplicationException,
            /// <summary>
            /// Is an application not allowed through the firewall
            /// </summary>
            NoApplicationException,
        }

        private readonly ushort TargetPort;

        private readonly string ApplicationName;

        private readonly FirewallVulnerabilityType VulnType;

        private readonly dynamic FirewallInterface;
        private readonly dynamic FirewallInterface2;

        /// <summary>
        /// A firewall related vulnerability
        /// </summary>
        /// <param name="points">The number of points to award on completion</param>
        /// <param name="VulnType">The type of firewall vulnerability to check</param>
        /// <param name="port">The port to check</param>
        public FirewallVulnerability(int points, FirewallVulnerabilityType VulnType, ushort port = 0) : base(points)
        {
            RegressionEnabled = true;
            TargetPort = port;
            this.VulnType = VulnType;
            FirewallInterface = Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FwMgr"));
            FirewallInterface2 = Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FwPolicy2"));
            OnCompleted += VulnCompleted;
            if(VulnType == FirewallVulnerabilityType.PortAllowed || VulnType == FirewallVulnerabilityType.PortBlocked)
            {
                Enabled = false; //Cant support this just yet, probably need a new type of vuln because it deals with far too many variables
            }
        }

        /// <summary>
        /// Internal use only
        /// </summary>
        public FirewallVulnerability() : base()
        {

        }

        /// <summary>
        /// A firewall related vulnerability
        /// </summary>
        /// <param name="points">The number of points to award on completion</param>
        /// <param name="VulnType">The type of firewall vulnerability to check</param>
        /// <param name="ApplicationName">The name of the application</param>
        public FirewallVulnerability(int points, FirewallVulnerabilityType VulnType, string ApplicationName) : base(points)
        {
            RegressionEnabled = true;
            this.ApplicationName = ApplicationName;
            this.VulnType = VulnType;
            FirewallInterface = Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FwMgr"));
            OnCompleted += VulnCompleted;
        }

        /// <summary>
        /// Create a vuln from string arguments
        /// </summary>
        /// <param name="args">0:points,1:vulntype,2?:appname or port</param>
        /// <returns></returns>
        public override Vulnerability TranslateArgs(params string[] args)
        {
            try
            {
                Enum.TryParse(args[1], true, out FirewallVulnerabilityType result);
                switch (result)
                {
                    case FirewallVulnerabilityType.ApplicationException:
                    case FirewallVulnerabilityType.NoApplicationException:
                        return new FirewallVulnerability(Convert.ToInt32(args[0]), result, args.Length > 2 ? args[2] : null);
                    default:
                        return new FirewallVulnerability(Convert.ToInt32(args[0]), result, Convert.ToUInt16(args.Length > 2 ? args[2] : "0"));
                }
            }
            catch
            {
                return null;
            }
        }

        private void VulnCompleted(Vulnerability vuln, VulnerabilityEventArgs e)
        {
            switch(VulnType)
            {
                case FirewallVulnerabilityType.Disabled:
                    Message = "Firewall has been disabled";
                    break;
                case FirewallVulnerabilityType.Enabled:
                    Message = "Firewall has been enabled";
                    break;
                case FirewallVulnerabilityType.PortAllowed:
                    Message = "Port " + TargetPort + " has been allowed through the firewall";
                    break;
                case FirewallVulnerabilityType.PortBlocked:
                    Message = "Port " + TargetPort + " has been blocked from passing through the firewall";
                    break;
                case FirewallVulnerabilityType.ApplicationException:
                    Message = ApplicationName + " has been allowed to pass through the firewall";
                    break;
                case FirewallVulnerabilityType.NoApplicationException:
                    Message = ApplicationName + " has been removed from passing through the firewall";
                    break;
            }
        }

        /// <summary>
        /// Evaluate the vulnerability conditions
        /// </summary>
        protected override void EvaluateVulnerability()
        {
            switch(VulnType)
            {
                case FirewallVulnerabilityType.Disabled:
                    Completed = !Convert.ToBoolean(FirewallInterface.LocalPolicy.CurrentProfile.FirewallEnabled);
                    break;
                case FirewallVulnerabilityType.Enabled:
                    Completed = Convert.ToBoolean(FirewallInterface.LocalPolicy.CurrentProfile.FirewallEnabled);
                    break;
                case FirewallVulnerabilityType.ApplicationException:
                    Completed = IsAppException(ApplicationName);
                    break;
                case FirewallVulnerabilityType.NoApplicationException:
                    Completed = !IsAppException(ApplicationName);
                    break;
            }
        }

        /// <summary>
        /// Finds an application in the firewall exceptions or returns false
        /// </summary>
        /// <param name="appname"></param>
        /// <returns></returns>
        private bool IsAppException(string appname)
        {
            try
            {
                foreach(dynamic fwapp in FirewallInterface.LocalPolicy.CurrentProfile.AuthorizedApplications)
                {
                    if (fwapp.Name.ToString().ToLower() == appname.ToLower())
                        return Convert.ToBoolean(fwapp.Enabled);
                }
            }
            catch
            {
                return false;
            }
            return false;
        }
    }
}
