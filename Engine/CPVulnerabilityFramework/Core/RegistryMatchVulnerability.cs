using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Win32;
using System.Data;

namespace CPVulnerabilityFramework.Core
{
    /// <summary>
    /// Success: Set registry value to correct value, Regress: Yes, Failure: Delete the whole key chain
    /// </summary>
    public sealed class RegistryMatchVulnerability : Vulnerability
    {
        private readonly object TargetValue;
        private readonly string ValueName;
        private readonly RegistryValueKind ValueKind;

        private readonly RegistryKey Key;

        /// <summary>
        /// A registry key based vulnerability
        /// </summary>
        /// <param name="PointValue">Points to award on completion</param>
        /// <param name="RootKey">The root key</param>
        /// <param name="SubKey">The subkey path</param>
        /// <param name="ValueName">The name of the value to evaluate</param>
        /// <param name="ValueKind">The kind of value to check for</param>
        /// <param name="TargetValue">The target value to compare against</param>
        public RegistryMatchVulnerability(int PointValue, RegistryKey RootKey, string SubKey, string ValueName, RegistryValueKind ValueKind, object TargetValue ) : base(PointValue)
        {
            this.TargetValue = TargetValue;
            this.ValueName = ValueName;
            this.ValueKind = ValueKind;
            try
            {
                Key = RootKey.OpenSubKey(SubKey);
                Enabled = true;
                OnCompleted += CompleteMessage;
                OnFailed += FailedMessage;
            }
            catch
            {
                Key = null;
                Enabled = false; //Disable the vuln because none of our methods are going to work now.
            }
        }

        /// <summary>
        /// Internal use only
        /// </summary>
        public RegistryMatchVulnerability() : base()
        {

        }

        /// <summary>
        /// Create a vuln from string parameters
        /// </summary>
        /// <param name="args">0:pointvalue, 1:rootkey, 2:subkey, 3:valuename, 4:valuekind, 5:targetvalue</param>
        /// <returns></returns>
        public override Vulnerability TranslateArgs(params string[] args)
        {
            try
            {
                int ipoints = Convert.ToInt32(args[0]);
                RegistryKey key = null;
                switch (args[1].ToUpper())
                {
                    case "HKEY_CLASSES_ROOT":
                    case "CLASSES_ROOT":
                    case "CLASSESROOT":
                    case "CLASSES":
                        key = Registry.ClassesRoot;
                        break;
                    case "HKEY_CURRENT_CONFIG":
                    case "CURRENT_CONFIG":
                    case "CURRENTCONFIG":
                    case "CONFIG":
                        key = Registry.CurrentConfig;
                        break;
                    case "HKEY_CURRENT_USER":
                    case "CURRENT_USER":
                    case "CURRENTUSER":
                    case "USER":
                        key = Registry.CurrentUser;
                        break;
                    case "HKEY_PERFORMANCE_DATA":
                    case "PERFORMANCE_DATA":
                    case "PERFORMANCEDATA":
                    case "PERFORMANCE":
                        key = Registry.PerformanceData;
                        break;
                    case "HKEY_USERS":
                    case "USERS":
                        key = Registry.Users;
                        break;
                    default:
                        key = Registry.LocalMachine;
                        break;
                }
                Enum.TryParse(args[4], true, out RegistryValueKind kind);
                return new RegistryMatchVulnerability(ipoints, key, args[2], args[3], kind, args[5]);
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Evalutate vulnerability status
        /// </summary>
        protected override void EvaluateVulnerability()
        {
            try
            {
                if (Key.GetValueKind(ValueName) == ValueKind)
                {
                    switch(ValueKind)
                    {
                        case RegistryValueKind.String:
                        case RegistryValueKind.ExpandString:
                        case RegistryValueKind.MultiString:
                            Completed = Key.GetValue(ValueName).ToString() == TargetValue.ToString();
                            return;
                        default:
                            Completed = Key.GetValue(ValueName) == TargetValue;
                            return;

                    }
                }
                Completed = false;
            }
            catch
            {
                Failed = true; //Ran into an exception, stop checking the registry key, might no longer exist
            }
        }

        private void CompleteMessage(Vulnerability sender, VulnerabilityEventArgs e)
        {
            Message = "Registry key " + Key.Name + " is correctly set to " + TargetValue.ToString();
        }

        private void FailedMessage(Vulnerability sender, VulnerabilityEventArgs e)
        {
            Message = "A registry value has been destroyed beyond repair!";
        }
    }
}
